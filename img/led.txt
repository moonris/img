每个通用 I/O 端口
4个配置寄存器
GPIOx_MODER            
GPIOx_OTYPER
GPIOx_OSPEEDR
GPIOx_PUPDR
2 个 32 位数据寄存器
GPIOx_IDR
GPIOx_ODR
1 个 32 位置位/复位寄存器
 GPIOx_BSRR
1 个 32 位锁定寄存器
GPIOx_LCKR
 和 2 个 32 位复用功能选择寄存器
GPIOx_AFRH
GPIOx_AFRL

1&0=0, 0&1=0, 0&0=0, 1&1=1
1|0=1, 0|1=1, 0|0=0, 1|1=1
~1=0,~0=1


void delay();
int main(void)
{
	RCC->AHB1ENR |=1<<7;                  //RCC AHB1 外设时钟使能寄存器 (RCC_AHB1ENR)    0 | 1 = 1
									
				          //GPIO PH 12~15
					输出模式，输出类型  端口输出类型 输出速度寄存器
	GPIOH->MODER&=~(3<<12*2);     //   思路：要输入模式“00”， 按位运算11<<12*2，此时，全零按大端or小端排列12位之中有两个1，取反，此时，全一按大端or小端排列12位之中有两个零，此时按位与寄存器 ，寄存器MODER 相应两位变为00，模式成功设置为00：输入         ** 00：输入，01：输出，10：复用，11：模拟
	GPIOH->MODER|=(3<<12*2);         //   思路：要输出模式“11”， 按位运算11<<12*2，此时，全零按大端or小端排列12位之中有两个1，此时按位或寄存器，寄存器MODER 相应两位变为一，模式成功设置为11：模拟
	GPIOH->OTYPER&=~(1<<12);        //   思路：0推挽，1开漏，，要推挽，1<<12 ~=0111 1111 1111 ，按位与，把寄存器相应位变零，
	GPIOH->OSPEEDR|=(3<<12*2);      //   思路：11高速  11<<12*2  1100 0000 0000 *2,按位或，寄存器相应为变11
	
	//流水灯
	while(1){
		for(int j=12;j<=15;j++){
				GPIOH->ODR&=~(1<<j);     //思路：1<<j位，取反变零，按位与寄存器，使寄存器相应为变零，
				delay();
				GPIOH->ODR|=(1<<j);         //思路：1<<j位，按位或寄存器，使寄存器相应为变一，
				delay();
		}
	}

	//跑马灯
	while(1){
			GPIOH->ODR&=~(1<<12);   //led1亮
			delay();			   //等待
					
			GPIOH->ODR&=~(1<<13);    //led1，2亮
			delay();			    //等待
				
			GPIOH->ODR&=~(1<<14);    //led1，2，3亮
			delay();                                         //等待
				
			GPIOH->ODR&=~(1<<15);     //led1，2，3，4亮
			delay();                                        //等待

			GPIOH->ODR|=(1<<15);          //LED1，2，3，4全暗
			delay();                                         //等待
			
			

	}

}
void delay(){
	for(int i=0;i<1000;i++){
		for(int j=0;j<1000;j++){
		;
		}
	}
}
